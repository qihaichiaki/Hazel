## learn

### 什么是游戏引擎?
实际让人们创建**交互式场景**的工具.
交互式场景? 实时显示图形的应用, 并且可以交互, 游戏是其中的一种类型.
目标: **将一组数据转换成另一组数据**, 然后将其从屏幕中渲染出来.(纹理/模型->游戏引擎(量身定制)=> 提供交互)
读取文件: 也就是资产, 可以是外部输入的, 也可以是游戏引擎创建的文件.
为了这些转换会抽象成诸多功能:: 平台抽象层、渲染、音频处理、文件序列化......

### 初步设计游戏引擎
随着时间逐步优化迭代。从基础的框架开始。

1. 我们需要一个入口.
2. 应用层（生命周期和事件）
3. 窗口层（绘制和事件都源于此）
	- 输入
	- 事件(事件管理器, 广播系统->)
4. render渲染器（复杂/庞大）
5. render api 渲染抽象层（OpenGL、DirectX、Vulkan...）
6. debug - 日志系统/配置文件系统(随时查找各个系统的实际效率, 方便优化)
7. 脚本系统 - 使用更高级的语言编写脚本
8. 内存系统 - > 内存对性能至关重要
9. ECS 世界中创建对象的方法
10. 物理系统
11. 文件输入输出,VFS(虚拟文件系统)
12. 构建系统(外部文件格式->引擎自定义格式, 运行时可以不用关心格式转换)
	- 热重载机制

### 项目设置
Hazel引擎

1. 目标: Hazel引擎实际上是一个动态库，创建一个外部应用程序, 是exe.然后将此dll链接到应用程序中即可.（其他依赖的模块为静态库，附着于引擎dll。对外提供此dll即可）
2. 项目设置：
	- 配置:debug/release
	- 平台: x64
	- 生成文件夹: build/bin/config-platform/project_name/
	- 中间文件生成目录: build/bin/int/config-platform/project_name/
3. SandBox 利用游戏引擎的应用程序 -> exe

4. 其他:
	1. 原项目使用的visual studio, 本项目是基于cmake+vscode尝试构建

### 入口点
* 切入点：主函数的流程控制希望是从**引擎的角度**去提供的，而非应用程序。

* 项目文件: 
	1. core.h 定义一些宏的地方(比如导出导入宏)
	2. appliaction.h/.cpp 引擎层抽象应用程序类，让真正的应用程序继承自此类, 自定义东西, 但是应用程序的流程可以做到在引擎层的main中进行控制 
	3. 应用层sandbox定义sandboxApp.cpp 继承自Application

* 为了应用层使用引擎头文件更加的便利, 类似于只提供给客户端应用程序包含的头文件, 但是引擎Hazel永远不会包含这个内容
	- 问题: 会不会头文件膨胀呢?

* 由于是引擎提供入口点, 则需要在引擎的文件夹下提供entryPoint.h 头文件, 里面定义了main函数, 应用程序只需要引入即可(由此main函数控制application的生命周期, 并且利用唯一的createApplication相关外部声明函数得到唯一的application载入运行)
* 入口文件可能随着平台的不同而不同(利用宏控制)
* 返回应用程序指针, 可以将其函数在Hazel中声明，然后从其他.cpp文件里去实现一次即可.
  * 现在的实现似乎只是简单实现new - delete 这些需要用户心知肚明(先暂时简单的实现)

### 日志记录
* 记录事件的一种方式. 使用一种方式和使用它的人交流(引擎娘!?(警觉))
  * 重点是随着代码的复杂度增加, 需要日志系统来告诉使用者究竟发生了什么(编写复杂代码和自己交流的过程)
  * 来自哪里, 严重程度, 发生了什么

* 日志库使用现成的库即可(日志库重点集中于格式化打印)：spdlog

* 使用三方库的时候，如果其存在公开仓库内，那么使用git submodule 更好(随时控制更新代码....)

* 实际上可以直接使用spdlog。但是需要封装, 算是一种引擎日志，并且能够定义简单的宏进行使用，并且也是未来日后的方便更改日志系统。目标: 尽量减少破坏性。

* 项目文件:
  1. log.h/log.cpp: 封装spdlog, 目标能够简单的调用日志。
     * 两个logger->引擎+App
     * 自定义格式、日志等级等等

* 设置格式，消息如何打出: [spdlog日志格式](https://github.com/gabime/spdlog/wiki/Custom-formatting)
* 创建支持多线程logger(同步mt), 设置logger名字, 设置筛选级别

* 日志的初始化。暂时在入口点进行调用(后续应该会迁移到系统初始化函数当中去)
* 日志加入到暴露给客户端的头文件中去
* 封装宏，让调用日志更方便，并且能够**统一控制**诸如debug日志在发布版本中不写日志
* 使用宏的级别: trace, info, warn, error, fatal